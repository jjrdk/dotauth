namespace DotAuth.Stores.Marten;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DotAuth.Shared.Models;
using DotAuth.Shared.Repositories;
using global::Marten;

/// <summary>
/// Defines the Marten based consent repository.
/// </summary>
/// <seealso cref="IConsentRepository" />
public sealed class MartenConsentRepository : IConsentRepository
{
    private readonly Func<IDocumentSession> _sessionFactory;

    /// <summary>
    /// Initializes a new instance of the <see cref="MartenConsentRepository"/> class.
    /// </summary>
    /// <param name="sessionFactory">The session factory.</param>
    public MartenConsentRepository(Func<IDocumentSession> sessionFactory)
    {
        _sessionFactory = sessionFactory;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyCollection<Consent>> GetConsentsForGivenUser(
        string subject,
        CancellationToken cancellationToken = default)
    {
        await using var session = _sessionFactory();
        var consents = await session.Query<Consent>()
            .Where(x => x.Subject == subject)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);
        return consents;
    }

    /// <inheritdoc />
    public async Task<bool> Insert(Consent record, CancellationToken cancellationToken = default)
    {
        await using var session = _sessionFactory();
        session.Store(record);
        await session.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

        return true;
    }

    /// <inheritdoc />
    public async Task<bool> Delete(Consent record, CancellationToken cancellationToken = default)
    {
        await using var session = _sessionFactory();
        session.Delete(record.Id);
        await session.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

        return true;
    }
}